---
title: "Extreme Dependence Data Analysis"
author: "Alex Reyes"
date: "2024-10-08"
output: html_document
---

***Cleaning the Workspace/Loading Required libraries***
```{r}
# Clean the workspace
rm(list = ls())

getwd()

# Load required packages
library(tidyverse)
library(tidyselect)
library(tidyquant)
library(quantmod)
library(timetk)
library(copula)
library(VineCopula)
library(cowplot)
library(infotheo)
library(GGally)
library(nortest)
library(car)
library(knitr)
library(kableExtra)
library(pander)
library(patchwork)
library(rugarch)
library(FinTS) 
library(reshape2)
```

***Functions for Stock Closing Prices/Log Returns/Wide-Format for Copula Analysis/plotting prices and log returns***
```{r}
# Create functions for tick marks
number_ticks <- function(n) { 
  function(limits) pretty(limits, n) 
}

date_ticks <- function(n) {
  function(limits) {
    pretty(seq(limits[1], limits[2], length.out = n), n)
  }
}

# Function to get and process stock prices
get_prices <- function(tickers, start_date, end_date, sector_name) {
  prices <- tq_get(tickers, from = start_date, to = end_date) |> 
    mutate(
      symbol = factor(symbol),
      sector = sector_name
    ) |> 
    group_by(symbol) |> 
    mutate(
      close_scaled = as.vector(scale(close)),  # Scale closing prices
      close_lgret = log(close / lag(close))  # Calculate log returns
    ) |> 
    ungroup() |> 
    drop_na() |> 
    select(date, sector, symbol, close, close_scaled, close_lgret)
  
  return(prices)
}

# Function to convert prices data to wide format for copula analysis
get_wide_prices <- function(prices) {
  wide_prices <- prices |> 
    select(date, symbol, close_lgret) |> 
    pivot_wider(names_from = symbol, values_from = close_lgret) |> 
    select(-date)
  
  return(wide_prices)
}

# Define start and end dates for the data
start_date <- "2016-01-01"
end_date <- "2023-12-31"

# Define tickers for the consumer discretionary sector
staples_tickers <- c(
  "COST", "WMT", "KO",
  "PEP", "TGT", "KR",
  "TSN", "CLX", "STZ",
  "MNST", "SYY", "PG")

# Define tickers for the communication services sector
communication_tickers <- c(
  "META", "GOOGL", "NFLX", 
  "DIS", "WBD", "PARA", 
  "CMCSA", "EA", "T", 
  "VZ", "TMUS", "OMC")

# Define tickers for the consumer staples sector
discretionary_tickers <- c(
  "AMZN", "TSLA", "HD",
  "MCD", "LOW", "NKE",
  "SBUX", "MAR", "EBAY",
  "BBY", "ETSY", "MGM")


## Filtering and Processing stocks for Consumer Staples Sector ##


# Fetch and process consumer staples sector stock prices
staples_prices <- get_prices(
  tickers = staples_tickers, 
  start_date = start_date, 
  end_date = end_date, 
  sector_name = "Consumer Staples"
)

staples_stable <- staples_prices |> 
  dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
staples_stable$period <- "Stable Market"
staples_stable <- staples_stable |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

staples_pandemic <- staples_prices |> 
  dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")
staples_pandemic$period <- "Pandemic and Downturn"
staples_pandemic <- staples_pandemic |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

# Combine the periods
staples_period <- rbind(
  staples_stable, staples_pandemic
) |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  ) |> 
  mutate(
    period = factor(
      period, 
      ordered = TRUE,
      levels = c("Stable Market", "Pandemic and Downturn")
    )
  )


## Filtering and Processing stocks for Consumer Discretionary Sector ##

discretionary_prices <- get_prices(
  tickers = discretionary_tickers, 
  start_date = start_date, 
  end_date = end_date, 
  sector_name = "Consumer Discretionary"
)

discretionary_stable <- discretionary_prices |> 
  dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
discretionary_stable$period <- "Stable Market"
discretionary_stable <- discretionary_stable |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

discretionary_pandemic <- discretionary_prices |> 
  dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")
discretionary_pandemic$period <- "Pandemic and Downturn"
discretionary_pandemic <- discretionary_pandemic |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

# Combine the periods ()
discretionary_period <- rbind(
  discretionary_stable, discretionary_pandemic
) |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  ) |> 
  mutate(
    period = factor(
      period, 
      ordered = TRUE,
      levels = c("Stable Market", "Pandemic and Downturn")
    )
  )


# Filtering and Processing stocks for Communication Services Sector

communication_prices <- get_prices(
  tickers = communication_tickers, 
  start_date = start_date, 
  end_date = end_date, 
  sector_name = "Communication Services"
)

communication_stable <- communication_prices |> 
  dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
communication_stable$period <- "Stable Market"
communication_stable <- communication_stable |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

communication_pandemic <- communication_prices |> 
  dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")
communication_pandemic$period <- "Pandemic and Downturn"
communication_pandemic <- communication_pandemic |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  )

# Combine the periods ()
communication_period <- rbind(
  communication_stable, communication_pandemic
) |> 
  select(
    date, period, sector, symbol, close, close_scaled, close_lgret
  ) |> 
  mutate(
    period = factor(
      period, 
      ordered = TRUE,
      levels = c("Stable Market", "Pandemic and Downturn")
    )
  )


```


***Functions for Spearman Correlation and TDC Computations/Plotting***
```{r}

# Compute the Tail Dependence Coefficient at the 5% percentile (Probability of Extreme Losses)
compute_tdc_matrix <- function(data, percentile = 0.05) {
  n <- nrow(data)
  percentile_value <- quantile(data[[1]], probs = percentile)
  
  # Find the number of observations below the percentile value
  k <- sum(data[[1]] <= percentile_value)
  
  # Compute the TDC matrix for the lower tail
  tdc_mat <- FRAPO::tdc(data, method = "EmpTC", lower = TRUE, k = k)
  
  return(tdc_mat)
}


# Function to plot dependency and tail dependence coefficient matrices
plot_dep_tdc <- function(data, cor_levels, percentile = 0.05) {
  
  # Compute Spearman correlation matrix
  corr_res <- Hmisc::rcorr(as.matrix(data), type = "spearman")
  corr_mat <- corr_res$r
  
  # Compute TDC matrix
  tdc_mat <- compute_tdc_matrix(data, percentile = percentile)
  
  combined_mat <- matrix(NA, 12, 12)
  colnames(combined_mat) <- colnames(corr_mat)
  rownames(combined_mat) <- colnames(corr_mat)
  
  combined_mat[lower.tri(combined_mat)] <- tdc_mat[lower.tri(tdc_mat)]
  combined_mat[upper.tri(combined_mat)] <- corr_mat[upper.tri(corr_mat)]
  combined_mat_long <- reshape2::melt(combined_mat, na.rm = FALSE) |> 
    mutate(
      Var1 = factor(Var1, levels = cor_levels, ordered = TRUE),
      Var2 = factor(Var2, levels = cor_levels, ordered = TRUE)
    )
  
  # Plotting
  combined_mat_long |> ggplot( 
    aes(
      x = Var1, y = Var2, 
      fill = value, 
      label = ifelse(!is.na(value), round(value, 2), "")
    )
  ) +
    geom_tile(color = "white") + 
    geom_text(color = "darkgray", size = 9, na.rm = TRUE) +
    scale_x_discrete(expand = c(0,0)) +
    scale_y_discrete(limits = rev, expand = c(0,0)) +
    scale_fill_distiller(
      palette = "RdBu", 
      direction = 1, 
      limits = c(0, 1), 
      na.value = "transparent", 
      name = NULL, 
      guide = guide_colourbar(
        barwidth = 25, barheight = 1.5
      )
    ) + 
    labs(fill = NULL) +
    theme_minimal() +
    theme(
      axis.title = element_blank(),
      axis.text.x = element_text(
        angle = 90, vjust = 0.5, hjust = 1, size = 24
      ),
      axis.text.y = element_text(size = 24),
      legend.position = "bottom",
      plot.title = element_text(hjust = 0.5, size = 34),
      legend.text = element_text(size = 24),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) -> joint_dep
  
  return(joint_dep)
}

# Wide format for stable periods, and pandemic periods for each sector
staples_stable_wide <- get_wide_prices(staples_stable)
staples_pandemic_wide <- get_wide_prices(staples_pandemic)

discretionary_stable_wide <- get_wide_prices(discretionary_stable)
discretionary_pandemic_wide <- get_wide_prices(discretionary_pandemic)

communication_stable_wide <- get_wide_prices(communication_stable)
communication_pandemic_wide <- get_wide_prices(communication_pandemic)


cor_levels <- colnames(
  Hmisc::rcorr(
    as.matrix(staples_stable_wide), 
    type = "spearman"
  )$r
)

# Example usage with the same structure as plot_dep_mat
cor_legend <- plot_dep_tdc(staples_stable_wide, cor_levels) +
  ggtitle("Stable Market")
cor_legend <- cowplot::get_plot_component(
  cor_legend, 'guide-box-bottom', return_all = TRUE
)

cor_title <- ggdraw() + 
  draw_label(
    "Spearman and tail dependence coefficient of log returns for the Consumer Staples sector",
    fontface = 'bold',
    size = 40,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 7)
  )

png(
  "cor_tdc_staples.png", 
  width = 1920, height = 1080
)
plot_grid(
  cor_title,
  NULL,
  plot_grid(
    plot_grid(
      plot_dep_tdc(staples_stable_wide, cor_levels, percentile = 0.05) +
        ggtitle("Stable Market") +
        theme(legend.position = "none"),
      plot_dep_tdc(staples_pandemic_wide, cor_levels, percentile = 0.05) +
        ggtitle("Pandemic and Downturn") +
        theme(legend.position = "none"),
      nrow = 1, rel_widths = c(1.4, 1.4)
    ),
    cor_legend,
    nrow = 2, rel_heights = c(1, 0.075)
  ),
  ncol = 1, rel_heights = c(0.1, 0.01, 1.4)
) -> joint_plot
print(joint_plot)
dev.off()

# Function to plot scaled closing prices of stocks
plot_stocks <- function(prices) {
  
  # Define the crisis periods
  crisis_periods <- data.frame(
    start = as.Date(
      c("2016-01-01", "2019-12-31")
    ),
    end = as.Date(
      c("2018-12-31", "2023-12-31")
    ),
    crisis = c(
      "Stable Market", "Pandemic and Downturn"
    )
  ) |> 
    mutate(crisis = factor(
      crisis, ordered = TRUE, 
      levels = c(
        "Stable Market", "Pandemic and Downturn"
      )
    )
    )
  
  # Custom color scale for stocks
  custom_colors <- c(
    "WMT" = "#FFA80A",   # Walmart
    "KR" = "#0A4EFF",   # Kroger
    "COST" = "#FF280A"    # Costco
  )
  
  other_stocks <- setdiff(unique(prices$symbol), names(custom_colors))
  custom_colors[other_stocks] <- "gray"
  
  # Define colors for crisis periods
  crisis_colors <- c(
    "Stable Market" = "#24f81e",
    "Pandemic and Downturn" = "#ffe700"
  )
  
  # Separate the data for special stocks and other stocks
  special_stocks <- prices |> filter(symbol %in% c("WMT", "KR", "COST"))
  other_stocks_data <- prices |> filter(!(symbol %in% c("WMT", "KR", "COST")))
  
  stock_plot <- ggplot() +
    # Plot the crisis periods
    geom_rect(
      data = crisis_periods, 
      aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = crisis),
      alpha = 0.45, inherit.aes = FALSE
    ) +
    # Plot the other stocks first
    geom_line(
      data = other_stocks_data, 
      aes(x = date, y = close_scaled, color = symbol, group = symbol), 
      linewidth = 1.5) +
    # Plot the special stocks on top
    geom_line(
      data = special_stocks, 
      aes(x = date, y = close_scaled, color = symbol, group = symbol), 
      linewidth = 1.5) +
    scale_color_manual(
      values = custom_colors,
      breaks = c("WMT", "KR", "COST"),
      labels = c("WMT", "KR", "COST")
    ) +
    scale_fill_manual(
      values = crisis_colors,
      breaks = c("Stable Market", "Pandemic and Downturn"),
      labels = c("Stable Market", "Pandemic and Downturn")
    ) +
    scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
    labs(
      x = NULL,
      y = "Scaled closing prices",
      color = NULL,
      fill = NULL
    ) +
    theme_minimal() +
    theme(
      axis.text = element_text(size = 24),
      axis.title = element_text(size = 24),
      legend.position = "bottom",
      legend.title = element_blank(),
      legend.text = element_text(size = 24),
      legend.box = "vertical",
      legend.box.just = "center",
      legend.spacing = unit(0.5, "cm"),
      legend.margin = margin(t = -10),
      panel.grid.minor = element_blank()
    ) + 
    guides(
      color = guide_legend(
        order = 1, 
        nrow = 1, 
        byrow = TRUE, 
        keyheight = unit(4, "lines"),
        override.aes = list(
          linetype = 1, 
          size = 20)
      ),
      fill = guide_legend(order = 2, override.aes = list(size = 12))
    )
  
  return(stock_plot)
}

# Function to plot periods
plot_periods <- function(periods, crisis_period, stock = c("WMT" = "#FFA80A")) {
  
  # Define the crisis periods
  crisis_periods <- data.frame(
    start = as.Date(
      c("2016-01-01", "2019-12-31")
    ),
    end = as.Date(
      c("2018-12-31", "2023-12-31")
    ),
    crisis = c(
      "Stable Market", "Pandemic and Downturn"
    )
  ) |> 
    mutate(crisis = factor(
      crisis, ordered = TRUE, 
      levels = c(
        "Stable Market", "Pandemic and Downturn"
      )
    )
    )
  
  # Define colors for crisis periods
  crisis_colors <- c(
    "Stable Market" = "#24f81e",
    "Pandemic and Downturn" = "#ffe700"
  )
  
  # Custom color scale for stocks
  custom_colors <- stock
  
  other_stocks <- setdiff(unique(periods$symbol), names(custom_colors))
  custom_colors[other_stocks] <- "gray"
  
  # Separate the data for special stocks and other stocks
  special_stocks <- periods |> filter(symbol %in% names(stock))
  other_stocks_data <- periods |> filter(!(symbol %in% names(stock)))
  
  ggplot() +
    # Plot the crisis periods
    geom_rect(
      data = filter(crisis_periods, crisis == crisis_period), 
      aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = crisis),
      alpha = 0.45, inherit.aes = FALSE
    ) +
    # Plot the other stocks first
    geom_line(
      data = filter(other_stocks_data, period == crisis_period),
      aes(x = date, y = close_lgret, group = symbol), 
      color = "gray", linewidth = 1.5) +
    # Plot the special stocks on top
    geom_line(
      data = filter(special_stocks, period == crisis_period),
      aes(x = date, y = close_lgret, color = symbol, group = symbol), 
      linewidth = 1.5) +
    scale_color_manual(
      values = custom_colors,
      breaks = names(stock),
      labels = names(stock)
    ) +
    scale_fill_manual(
      values = crisis_colors,
      breaks = c("Stable Market", "Pandemic and Downturn"),
      labels = c("Stable Market", "Pandemic and Downturn")
    ) +
    scale_x_date(breaks = date_ticks(5), date_labels = "%Y") +  
    scale_y_continuous(
      breaks = c(-0.4, -0.2, 0, 0.2, 0.4),
      labels = c(-0.4, -0.2, 0, 0.2, 0.4),
      limits = c(-0.5, 0.5)
    ) +
    labs(
      title = NULL,
      x = NULL,
      y = " "
    ) +
    theme_minimal() +
    theme(
      axis.text = element_text(size = 24),
      axis.title = element_text(size = 24),
      legend.position = "none",
      plot.margin = margin(5.5, 15.5, 5.5, 5.5), 
      panel.grid.minor = element_blank(),
    )  -> plot_periods
  
  return(plot_periods)
}

# Generate the individual plots
plot1 <- plot_grid(
  plot_periods(staples_period, "Stable Market", c("WMT" = "#FFA80A")) + 
    labs(y = " ") +
    theme(axis.text.x = element_text(color = "white")),
  plot_periods(staples_period, "Pandemic and Downturn", c("WMT" = "#FFA80A")) +
    labs(y = " ") +
    theme(axis.text = element_text(color = "white")),
  nrow = 1,
  rel_widths = c(1, 1)
)

plot2 <- plot_grid(
  plot_periods(staples_period, "Stable Market", c("KR" = "#0A4EFF")) + 
    labs(y = "Log returns of closing prices") +
    theme(axis.text.x = element_text(color = "white")),
  plot_periods(staples_period, "Pandemic and Downturn", c("KR" = "#0A4EFF")) +
    labs(y = " ") +
    theme(axis.text = element_text(color = "white")),
  nrow = 1,
  rel_widths = c(1, 1)
)

plot3 <- plot_grid(
  plot_periods(staples_period, "Stable Market", c("COST" = "#FF280A")) + 
    labs(y = " "),
  plot_periods(staples_period, "Pandemic and Downturn", c("COST" = "#FF280A")) +
    labs(y = " ") +
    theme(axis.text.y = element_text(color = "white")),
  nrow = 1,
  rel_widths = c(1, 1)
)

# Combine all plots
log_returns_periods <- plot_grid(
  plot1,
  plot2,
  plot3,
  nrow = 3,
  rel_heights = c(1, 1, 1),
  align = 'v'
)

stocks_legend <- plot_stocks(staples_prices)
stocks_legend <- cowplot::get_plot_component(
  stocks_legend, 'guide-box-bottom', return_all = TRUE
)

stocks_title <- ggdraw() + 
  draw_label(
    "Log returns of selected Consumer Staples sector stocks in the S&P500",
    fontface = 'bold',
    size = 40,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 7)
  )

png(
  "log_returns_consumer.png", 
  width = 1920, height = 1080*0.9
)
plot_grid(
  stocks_title,
  NULL,
  plot_grid(
    plot_grid(
      plot_stocks(staples_prices) +
        theme(legend.position = "none"),
      log_returns_periods,
      ncol = 2
    ),
    NULL,
    stocks_legend,
    ncol = 1, rel_heights = c(1, 0.01, 0.1)),
  ncol = 1, rel_heights = c(0.1, 0.01, 1.4)
) -> stocks_main
print(stocks_main)
dev.off()



# Transform log returns into pseudo-observations (uniform margins)

# Function to plot the copula
plot_cop <- function(data, symbol_x, symbol_y, symbol_x_label, symbol_y_label) {
  
  pobs_log_returns <- pobs(as.matrix(data))
  pobs_log_returns <- as.data.frame(pobs_log_returns)
  names(pobs_log_returns) <- names(data)
  
  u <- pobs_log_returns[, symbol_x]
  v <- pobs_log_returns[, symbol_y]
  selectedCopula <- BiCopSelect(u, v)
  
  # Simulate data from the fitted copula
  simulated_data <- BiCopSim(
    1000, 
    family = selectedCopula$family, 
    par = selectedCopula$par, 
    par2 = selectedCopula$par2
  )
  
  # Create a data frame for ggplot2
  df <- data.frame(u = simulated_data[, 1], v = simulated_data[, 2])
  
  df_data <- pobs_log_returns[, c(symbol_x, symbol_y)]
  names(df_data) <- c("x", "y")
  
  # Create the contour plot without grid background
  ggplot(df, aes(x = u, y = v)) +
    stat_density_2d(aes(fill = ..level..), geom = "polygon") +
    geom_point(
      data = df_data,
      aes(x, y),
      shape = 19, size = 4, 
      color = "black", fill = "gray", 
      alpha = 0.4
    ) +
    scale_fill_viridis_c(alpha = 0.9) +
    labs(
      x = symbol_x_label, 
      y = symbol_y_label
    ) +
    theme_minimal() +
    theme(
      legend.position = "none",
      axis.text = element_text(size = 24),
      axis.title = element_text(size = 24),
      plot.title = element_text(face = "bold", size = 34),
      plot.title.position = "plot",
      panel.grid.minor = element_blank()
    ) -> cop_plot
  
  return(cop_plot)
  
}  

png(
  "copula_consumer.png", 
  width = 720, height = 720
)

plot_cop(
  staples_stable_wide, 
  "HD", "LOW", "Log Return - Stock X", "Log Return - Stock Y"
) + ggtitle("Bivariate Stock Dependency via Copula") -> cop_plot
print(cop_plot)
dev.off()



percentile <- 0.05
data <- staples_pandemic_wide
# Compute Spearman correlation matrix
corr_res <- Hmisc::rcorr(as.matrix(data), type = "spearman")
corr_mat <- corr_res$r
View(corr_mat)

# Compute TDC matrix
tdc_mat <- compute_tdc_matrix(data, percentile = percentile)
View(tdc_mat)

```

***Testing ARCH Effects, and Fitting one when necessary (significant P-value)***
```{r}


#' Test for ARCH effects and fit a GARCH(1,1) model if necessary
#'
#' This function takes a time series of log-returns (numerical vector) as input, 
#' performs an ARCH test using the FinTS::ArchTest function, and checks whether 
#' a GARCH structure is necessary. If the ARCH test indicates the need for a GARCH model, 
#' the function fits a GARCH(1,1) model using the rugarch package and returns the residuals.
#' If the ARCH test fails (i.e., no GARCH structure is necessary), it simply returns the input time series.
#'
#' @param x A numerical vector containing the time series of log-returns.
#' @param lags The number of lags for the ARCH test (default is 5).
#' @param alpha The significance level for the ARCH test (default is 0.05).
#' 
#' @return If no ARCH effects are found, the function returns the original time series. 
#' If ARCH effects are detected, it returns the residuals of the fitted GARCH(1,1) model.
#'
#' @examples
#' # Example with simulated GARCH(1,1) data:
#' n <- 1000
#' x <- as.numeric(fitted(ugarchpath(ugarchspec(), n.sim = n)))
#' result <- test_and_fit_garch(x)
#' print(result)
#'
#' @import rugarch
#' @import FinTS
#' @export
test_and_fit_garch <- function(x, lags = 5, alpha = 0.05) {
  
  # Step 1: Perform the ARCH test using FinTS::ArchTest
  arch_test <- FinTS::ArchTest(x, lags = lags)
  
  # Extract the p-value from the test
  p_value <- arch_test$p.value
  
  # Step 2: Decision rule based on p-value
  if (p_value >= alpha) {
    # If the p-value is greater than alpha, no ARCH effects are detected
    print("No significant ARCH effects. A GARCH model might not be necessary.")
    return(x)  # Return the original time series
  } else {
    # If the p-value is less than alpha, ARCH effects are detected
    print("There is evidence of ARCH effects. A GARCH model may be necessary.")
    
    # Step 3: Fit the GARCH(1,1) model to the data 'x'
    garch_spec <- ugarchspec(
      variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
      mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
      distribution.model = "norm"
    )
    
    # Fit the model
    garch_fit <- ugarchfit(spec = garch_spec, data = x)
    
    # Step 4: Extract the residuals
    garch_residuals <- residuals(garch_fit)
    
    # Return the residuals of the GARCH(1,1) model
    return(as.numeric(garch_residuals))
  }
}

# List of data frames for each sector
sectors_log_returns <- list(
  communication = communication_period,
  discretionary = discretionary_period,
  staples = staples_period
)

# Initialize an empty data frame to store the GARCH results
garch_results <- data.frame(
  date = as.Date(character()),
  sector = character(),
  symbol = character(),
  residual = numeric(),
  passed_garch_test = logical()
)

# Loop through each sector
for (sector_name in names(sectors_log_returns)) {
  
  # Get the data for the current sector
  sector_data <- sectors_log_returns[[sector_name]]
  
  # Get the unique stock symbols in this sector
  stock_symbols <- unique(sector_data$symbol)
  
  # Loop through each stock
  for (stock in stock_symbols) {
    
    # Extract the log-returns and dates for the current stock
    stock_data <- sector_data[sector_data$symbol == stock, ]
    dates <- stock_data$date  # Assuming 'date' column exists
    log_returns <- stock_data$close_lgret
    
    # Run the GARCH test and fit function
    garch_result <- test_and_fit_garch(log_returns)
    
    # Determine if the GARCH model was fitted
    passed_garch_test <- !identical(log_returns, garch_result)
    
    # Add each entry as a separate row to the garch_results data frame
    for (i in seq_along(dates)) {
      garch_results <- rbind(
        garch_results,
        data.frame(
          date = dates[i],
          sector = sector_name,
          symbol = stock,
          residual = garch_result[i],
          passed_garch_test = passed_garch_test
        )
      )
    }
  }
}

# head(garch_results) 

# META, NFLX, TGT are the only symbols that did not pass the GARCH Test, because of this the data frame, 'garch_results' will keep the log returns for those symbols.


```


***Example of Using Garch Function Above***
```{r}
# Let's simulate some data from a GARCH(1, 1) and check our function

# Set the GARCH(1,1) model specifications with starting parameter values
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  distribution.model = "norm", 
  fixed.pars = list(mu = 0, omega = 0.1, alpha1 = 0.1, beta1 = 0.8) # Specify parameter values
)


# Simulate n = 1000 data points from the GARCH(1,1) model
n <- 1000
x <- as.numeric(fitted(ugarchpath(spec, n.sim = n)))

# Plot the simulated GARCH data
plot(x, type = "l", col = "blue", main = "Simulated GARCH(1,1) Time Series", 
     xlab = "Time", ylab = "Value")

# Checking our function
fit_x <- test_and_fit_garch(x)

# Now, let's simulate white noise and re-check our function
y <- rnorm(n, mean = 0, sd = 1)

# Plot the simulated GARCH data
plot(y, type = "l", col = "blue", main = "Simulated Random Walk Time Series", 
     xlab = "Time", ylab = "Value")

# Re-checking our function
fit_y <- test_and_fit_garch(y)

```


***Now that we got 'garch_results', we are going to filtering everything out again into its sectors to we can then perform analysis for each stock sector***
```{r}

# Create separate data frames for each sector
garch_communication <- garch_results |> filter(sector == "communication")
garch_discretionary <- garch_results |> filter(sector == "discretionary")
garch_staples <- garch_results |> filter(sector == "staples")


# Now we are going to separate each dataframe further for stable, and pandemic periods

# Filtering for the communication services sector
garch_communication_stable <- garch_communication |>
    dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
  
garch_communication_pandemic <- garch_communication |> 
    dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")

# Filtering for the consumer discretionary sector
garch_discretionary_stable <- garch_discretionary |> 
    dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
  
garch_discretionary_pandemic <- garch_discretionary |> 
    dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")

# Filtering for the consumer staples sector
garch_staples_stable <- garch_staples |> 
    dplyr::filter(date >= "2016-01-01" & date <= "2018-12-31")
  
garch_staples_pandemic <- garch_staples |> 
    dplyr::filter(date >= "2019-12-31" & date <= "2023-12-31")


```

***function to turn GARCH data frames to wide format***
```{r}
get_wide_residuals <- function(residuals) {
  wide_residuals <- residuals |> 
    select(date, symbol, residual) |> 
    pivot_wider(names_from = symbol, values_from = residual) |> 
    select(-date)
  
  return(wide_residuals)
}

```

***Wide format for GARCH dataframes***
```{r}

# Wide format for the communication services 
garch_communication_stable_wide <- get_wide_residuals(garch_communication_stable)

garch_communication_pandemic_wide <- get_wide_residuals(garch_communication_pandemic)

# Wide format for the consumer discretionary 
garch_discretionary_stable_wide <- get_wide_residuals(garch_discretionary_stable)

garch_discretionary_pandemic_wide <- get_wide_residuals(garch_discretionary_pandemic)

# Wide format for the consumer staples
garch_staples_stable_wide <- get_wide_residuals(garch_staples_stable)

garch_staples_pandemic_wide <- get_wide_residuals(garch_staples_pandemic)


```


***Creating Matrix Plots for Communication Services***
```{r}


library(viridis)  # for colorblind-friendly palette

# Define the order of stock symbols
communication_tickers <- c("META", "GOOGL", "NFLX", "DIS", "WBD", "PARA", "CMCSA", "EA", "T", "VZ", "TMUS", "OMC")

# Helper function to reshape a matrix into a long format for ggplot, keeping only the lower triangle
reshape_for_ggplot <- function(matrix, names) {
  as.data.frame(matrix) %>%
    rownames_to_column(var = "Var1") %>%
    pivot_longer(-Var1, names_to = "Var2", values_to = "value") %>%
    mutate(
      Var1 = factor(Var1, levels = names, ordered = TRUE),
      Var2 = factor(Var2, levels = names, ordered = TRUE)
    ) %>%
    filter(as.numeric(Var1) > as.numeric(Var2))  # Keep only lower triangle
}

# Function to plot the Spearman Correlation
plot_spearman_correlation_ggplot <- function(wide_data, title) {
  # Calculate Spearman correlation matrix
  spearman_corr <- cor(wide_data, method = "spearman", use = "pairwise.complete.obs")
  
  # Reshape for ggplot
  corr_data <- reshape_for_ggplot(spearman_corr, communication_tickers)
  
  # Plot with values inside the tiles
  ggplot(corr_data, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 2)), color = "black", size = 3) +  # Display correlation values
    scale_fill_viridis_c(option = "C", limits = c(-1, 1), name = "Spearman\nCorrelation") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.text.y = element_text(size = 10)
    ) +
    labs(title = title, x = "", y = "") +
    coord_fixed()
}

# Function to compute Mutual Information matrix for a wide-format data frame
compute_mutual_information_matrix <- function(wide_data) {
  discretized_data <- discretize(wide_data)
  n <- ncol(discretized_data)
  mi_matrix <- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      mi_matrix[i, j] <- mutinformation(discretized_data[, i], discretized_data[, j])
    }
  }
  
  colnames(mi_matrix) <- colnames(wide_data)
  rownames(mi_matrix) <- colnames(wide_data)
  
  return(mi_matrix)
}

# Plotting function for Mutual Information matrix
plot_mutual_information_matrix <- function(wide_data, title) {
  mi_matrix <- compute_mutual_information_matrix(wide_data)
  mi_data <- reshape_for_ggplot(mi_matrix, communication_tickers)
  
  ggplot(mi_data, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 2)), color = "black", size = 3) +  # Display MI values
    scale_fill_viridis_c(option = "C", name = "Mutual\nInformation") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.text.y = element_text(size = 10)
    ) +
    labs(title = title, x = "", y = "") +
    coord_fixed()
}

# Function to compute Tail Dependence Coefficient (TDC) matrix
compute_tdc_matrix <- function(data, percentile = 0.05) {
  n <- nrow(data)
  percentile_value <- quantile(data[[1]], probs = percentile)
  k <- sum(data[[1]] <= percentile_value)
  tdc_mat <- FRAPO::tdc(data, method = "EmpTC", lower = TRUE, k = k)
  return(tdc_mat)
}

# Function to plot Tail Dependence Coefficient (TDC) matrix with only the lower triangle
plot_tdc_mat <- function(data, title, percentile = 0.05) {
  tdc_mat <- compute_tdc_matrix(data, percentile = percentile)
  tdc_mat[upper.tri(tdc_mat)] <- NA
  tdc_long <- reshape_for_ggplot(tdc_mat, communication_tickers)
  
  ggplot(tdc_long, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 2)), color = "black", size = 3, na.rm = TRUE) +
    scale_fill_viridis_c(option = "C", limits = c(0, 1), name = "TDC") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.text.y = element_text(size = 10),
      legend.position = "bottom"
    ) +
    labs(title = title, x = "", y = "") +
    coord_fixed()
}

# Example usage
plot_spearman_correlation_ggplot(garch_communication_stable_wide, "Spearman Correlation for Communication Services (Stable Period)")
plot_spearman_correlation_ggplot(garch_communication_pandemic_wide, "Spearman Correlation for Communication Services (Pandemic Period)")

plot_mutual_information_matrix(garch_communication_stable_wide, "Mutual Information for Communication Services (Stable Period)")
plot_mutual_information_matrix(garch_communication_pandemic_wide, "Mutual Information for Communication Services (Pandemic Period)")

plot_tdc_mat(garch_communication_stable_wide, "TDC for Communication Services (Stable Period)")
plot_tdc_mat(garch_communication_pandemic_wide, "TDC for Communication Services (Pandemic Period)")



```



```{r}
# TDC plots for the Consumer Discretionary Sector
cor_levels_discretionary_stable <- colnames(garch_discretionary_stable_wide)
plot_tdc_mat(garch_discretionary_stable_wide, cor_levels = cor_levels_discretionary_stable, percentile = 0.05)

cor_levels_discretionary_pandemic <- colnames(garch_discretionary_pandemic_wide)
plot_tdc_mat(garch_discretionary_pandemic_wide, cor_levels = cor_levels_discretionary_pandemic, percentile = 0.05)


# TDC plots for the Consumer Staples Sector
cor_levels_staples_stable <- colnames(garch_staples_stable_wide)
plot_tdc_mat(garch_staples_stable_wide, cor_levels = cor_levels_staples_stable, percentile = 0.05)

cor_levels_staples_pandemic <- colnames(garch_staples_pandemic_wide)
plot_tdc_mat(garch_staples_pandemic_wide, cor_levels = cor_levels_staples_pandemic, percentile = 0.05)
```

***Calculating Expected Shortfall at the 5% percentile***
```{r}

# Function to calculate Expected Shortfall at 95% confidence level (5% quantile)
calculate_es <- function(residuals, quantile = 0.05) {
  threshold <- quantile(residuals, probs = quantile, na.rm = TRUE)
  es <- abs(mean(residuals[residuals <= threshold], na.rm = TRUE))  # Absolute value of ES
  return(es)
}

# Function to compute the ES matrix with only the lower triangle populated
compute_es_matrix <- function(garch_residuals, quantile = 0.05) {
  asset_names <- colnames(garch_residuals)
  n <- ncol(garch_residuals)
  es_matrix <- matrix(NA, n, n)
  colnames(es_matrix) <- asset_names
  rownames(es_matrix) <- asset_names
  
  for (i in 1:n) {
    es_i <- calculate_es(garch_residuals[, i], quantile)
    for (j in 1:i) {  # Populate only lower triangle (including diagonal)
      es_matrix[i, j] <- es_i
      es_matrix[j, i] <- es_i  # Make it symmetric if needed
    }
  }
  return(es_matrix)
}

# Function to plot only the lower triangle of the ES matrix using ggplot2
plot_es_matrix <- function(es_matrix) {
  # Convert matrix to long format for ggplot2
  es_long <- melt(es_matrix, na.rm = TRUE) %>%
    mutate(
      Var1 = factor(Var1, levels = rownames(es_matrix), ordered = TRUE),
      Var2 = factor(Var2, levels = colnames(es_matrix), ordered = TRUE)
    ) %>%
    filter(as.numeric(Var1) >= as.numeric(Var2))  # Keep only lower triangle
  
  # Plotting the ES matrix
  ggplot(es_long, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 4)), color = "black", size = 3, na.rm = TRUE) +
    scale_fill_gradient2(
      low = "blue", mid = "white", high = "red", 
      midpoint = median(es_long$value, na.rm = TRUE), 
      limit = c(min(es_long$value, na.rm = TRUE), max(es_long$value, na.rm = TRUE)), 
      name = "Expected Shortfall\n(95% Confidence)"
    ) +
    labs(title = "Expected Shortfall (ES) Matrix at 5% Percentile") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    coord_fixed()
}

# Example usage with garch_communication_stable_wide
# Assuming `garch_communication_stable_wide` is a data frame with GARCH residuals in wide format
es_matrix <- compute_es_matrix(garch_communication_stable_wide, quantile = 0.05)
plot_es_matrix(es_matrix)


# Function to calculate Value at Risk at 95% confidence level (5% quantile)
calculate_var <- function(residuals, quantile = 0.05) {
  var <- quantile(residuals, probs = quantile, na.rm = TRUE)
  return(abs(var))  # Use absolute value to represent risk level as positive
}

# Function to compute the VaR matrix with only the lower triangle populated
compute_var_matrix <- function(garch_residuals, quantile = 0.05) {
  asset_names <- colnames(garch_residuals)
  n <- ncol(garch_residuals)
  var_matrix <- matrix(NA, n, n)
  colnames(var_matrix) <- asset_names
  rownames(var_matrix) <- asset_names
  
  for (i in 1:n) {
    var_i <- calculate_var(garch_residuals[, i], quantile)
    for (j in 1:i) {  # Populate only lower triangle (including diagonal)
      var_matrix[i, j] <- var_i
      var_matrix[j, i] <- var_i  # Make it symmetric if needed
    }
  }
  return(var_matrix)
}

# Function to plot only the lower triangle of the VaR matrix using ggplot2
plot_var_matrix <- function(var_matrix) {
  # Convert matrix to long format for ggplot2
  var_long <- melt(var_matrix, na.rm = TRUE) %>%
    mutate(
      Var1 = factor(Var1, levels = rownames(var_matrix), ordered = TRUE),
      Var2 = factor(Var2, levels = colnames(var_matrix), ordered = TRUE)
    ) %>%
    filter(as.numeric(Var1) >= as.numeric(Var2))  # Keep only lower triangle
  
  # Plotting the VaR matrix
  ggplot(var_long, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile(color = "white") +
    geom_text(aes(label = round(value, 4)), color = "black", size = 3, na.rm = TRUE) +
    scale_fill_gradient2(
      low = "blue", mid = "white", high = "red", 
      midpoint = median(var_long$value, na.rm = TRUE), 
      limit = c(min(var_long$value, na.rm = TRUE), max(var_long$value, na.rm = TRUE)), 
      name = "Value at Risk\n(95% Confidence)"
    ) +
    labs(title = "Value at Risk (VaR) Matrix at 95% Confidence Level") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    coord_fixed()
}

# Example usage with garch_communication_stable_wide
# Assuming `garch_communication_stable_wide` is a data frame with GARCH residuals in wide format
var_matrix <- compute_var_matrix(garch_communication_stable_wide, quantile = 0.05)
plot_var_matrix(var_matrix)


# Need to change the plot for the JOINT VaR, right now I'm only computing individual columns

```

